**Software Platform**

The data quality check, cleaning process and visualisation creation and analysis for this study will be conducted using the RStudio platform version 2023.06.1, Build 524.

**Setting Up the Working Directory and Loading Data**

### Set Directory

```{r}
# Set the root directory path 
root.dir = "C:/Users/RR/Desktop/GitHub Projects/ANL501-Data Visualisation & Story Telling/Assignments & Quizzes/Assignments/ECA/Data"
```

### Load Data

```{r}
# Load readxl package for reading Excel files
library(readxl)

# Read Excel file named "FoodAid.xlsx" and store as 'df' dataframe
df <- read_excel("FoodAid.xlsx")
```

### Install Packages

```{r}
# Install necessary R packages for data manipulation, visualisation and mapping
install.packages(c("stringr",     # For string manipulation functions
                   "dplyr",       # For data manipulation functions
                   "ggplot2",     # For creating visualisations using grammar of graphics
                   "patchwork",   # For arranging multiple ggplots into a single figure
                   "WDI",         # For accessing World Bank data
                   "leaflet",     # For creating interactive maps
                   "ggrepel",     # For adding non-overlapping text labels to ggplot2 plots
                   "scales"))     # For modifying axis scales and breaks in ggplot2
```

### Install Libraries

```{r}
# Load necessary libraries for data manipulation and visualisation
library(stringr)      # For string manipulation functions
library(dplyr)        # For data manipulation functions
library(ggplot2)      # For creating visualisations
library(patchwork)    # For combining multiple ggplot2 plots
library(WDI)          # For accessing World Bank data
library(leaflet)      # For creating interactive maps
library(ggrepel)      # For adding text labels to ggplot2 plots
library(scales)       # For scaling functions for ggplot2
```

**Data Management**

a.  Examine the Dataset

Based on the data dictionary, certain variables represent the cumulative totals of various distinct variables. For this reason, it is important to consider the following aspects:

i.  The "overall_conflict" variable denotes the aggregate of both the "minor_conflict" and "major_conflict" variables.

ii. "Total_affected_disasters" corresponds to the summation of "affected_disasters" and "homeless_disasters" variables.

iii. "Total_affected_othercountries" is derived from the summation of "total_affected_neighbours," "total_affected_non_neighbours," and "nda_other_region" variables.

It should be noted that these sets of variables may not be compatible for simultaneous utilisation during the data exploration phase, as doing so may impede the attainment of accurate visualisation representation.

b.  Data Structure

### Data Types

```{r}
# Retrieve the column names 
colnames(df)

# Display the first few rows 
head(df)

# Provide summary of data structure
str(df)

```

c.  Data Transformation

### Convert numeric variables, such as overall_conflict, minor_conflict, major_conflict, onsetwar, offsetwar, and polity2 into Categorical factors

```{r}
# Convert variables to factors with "No" and "Yes" labels
df <- df %>%
  mutate(
    overall_conflict = factor(overall_conflict, levels = c(0, 1), labels = c("No", "Yes")),
    minor_conflict = factor(minor_conflict, levels = c(0, 1), labels = c("No", "Yes")),
    major_conflict = factor(major_conflict, levels = c(0, 1), labels = c("No", "Yes")),
    onsetwar = factor(onsetwar, levels = c(0, 1), labels = c("No", "Yes")),
    offsetwar = factor(offsetwar, levels = c(0, 1), labels = c("No", "Yes")),
    
    # Create categories for "polity2" scores
    polity2_category = cut(polity2,
                           breaks = c(-10, -6, 0, 5, 9, 10),  # Define breaks for categorization
                           labels = c("Highly Autocratic", "Moderately Autocratic", "Neutral/Transitional", "Moderately Democratic", "Highly Democratic"),  # Define labels for each category
                           include.lowest = TRUE)  # Include lowest value in the first interval
  )

```

### Creating New Variables

```{r}
# Mutate the dataframe to calculate the total food aid by summing emergency and non-emergency food aid
# Calculate the percentage of total food aid compared to total aid
# Compute the total GDP by multiplying GDP per capita with population
df <- df %>%
  mutate(
    total_food_aid = emergency_food_aid + non_emergency_food_aid,
    percent_total_food_aid_of_total_aid = total_food_aid / total_aid,
    total_gdp = gdp_per_capita * population
  )
```

### Extract the Year from the 'year' Column for Data Merging

```{r}
# Extract the first four characters from the 'year' column and create a new column called 'year'
df <- df %>%
  mutate(year = substr(year, 1, 4))
```

d.  Additional Data Abstraction

### Abstract Additional Data from WDI API

```{r}
# Define the list of Sub-Saharan African countries
sub_saharan_africa_countries <- c(
  "AO", "BJ", "BF", "BI", "CV", "CM", "CF", "TD", "KM", "CG", "CI", "DJ", "ER",
  "SZ", "ET", "GM", "GH", "GN", "GW", "KE", "LS", "LR", "MG", "MW", "ML", "MR",
  "MZ", "NA", "NE", "NG", "RW", "SN", "SL", "SO", "ZA", "SD", "TZ", "TG", "UG",
  "ZM", "ZW", "CD"
)

# Define the list of indicators
indicators <- c(
  "MS.MIL.XPND.CD",     # Military Expenses
  "SN.ITK.DEFC.ZS"      # Prevalence of Undernourishment
)

# Fetch WDI data for the selected indicators and countries
wdi_data <- WDI(
  country = sub_saharan_africa_countries,
  indicator = indicators,
  start = 2002,
  end = 2020
)

# View the retrieved data
View(wdi_data)
```

e.  Merging Data

### Data Transformation for Merging WDI Data

```{r}
# Rename specific countries in the dataset to match common naming conventions
wdi_data <- wdi_data %>%
  mutate(
    country = case_when(
      country == "Congo, Rep." ~ "Congo",  # Change "Congo, Rep." to "Congo"
      country == "Congo, Dem. Rep." ~ "Democratic Republic of the Congo",  # Change "Congo, Dem. Rep." to "Democratic Republic of the Congo"
      country == "Gambia, The" ~ "Gambia",  # Change "Gambia, The" to "Gambia"
      TRUE ~ country  # Keep other values unchanged
    )
  )
```

### Convert the 'year' Column in the 'df' DataFrame to Integer and Perform Data Merging

```{r}
# Convert the 'year' column in dataframe 'df' to integer type
df$year <- as.integer(df$year)

# Merge dataframe 'df' with dataframe 'wdi_data' based on the common columns 'country' and 'year', storing the result in dataframe 'df2'
df2 <- left_join(df, wdi_data, by = c("country", "year"))

# Write the merged dataframe 'df2' to a CSV file named 'df2.csv', excluding row names
write.csv(df2, file = "df2.csv", row.names = FALSE)

# Display the first few rows of the merged dataframe 'df2'
head(df2)
```

### Rename variables

```{r}
# Renaming columns in dataframe df2 using the pipe operator %>%
df2 <- df2 %>%
  rename(
    "Military Expenditure" = MS.MIL.XPND.CD, # Renaming column MS.MIL.XPND.CD to "Military Expenditure"
    "Prevalence of Undernourishment" = SN.ITK.DEFC.ZS # Renaming column SN.ITK.DEFC.ZS to "Prevalence of Undernourishment"
  )
```

f.  Missing Values

### Check for missing values

```{r}
# Calculate the count of missing values for each column in df2
df2.missingcounts <- colSums(is.na(df2))

# Filter columns where the count of missing values is greater than 100
df2.missingcounts[df2.missingcounts > 100] # not more than 100 data rows
```

### Creating and Storing Country Locations

```{r}
# Create a data frame with coordinates for multiple countries
Coordinates <- data.frame(
  Country = c("Angola", "Benin", "Burkina Faso", "Burundi", "Cape Verde", "Cameroon", 
              "Central African Republic", "Chad", "Comoros", "Republic of the Congo", 
              "CÃ´te d'Ivoire", "Djibouti", "Eritrea", "Eswatini", "Ethiopia", "Gambia", 
              "Ghana", "Guinea", "Guinea-Bissau", "Kenya", "Lesotho", "Liberia",
              "Madagascar", "Malawi", "Mali", "Mauritania", "Mozambique", "Namibia",
              "Niger", "Nigeria", "Rwanda", "Senegal", "Sierra Leone", "Somalia",
              "South Africa", "Sudan", "Tanzania", "Togo", "Uganda", "Zambia", "Zimbabwe",
              "Democratic Republic of the Congo"),
  Longitude = c(17.873887, 2.315834, -1.561593, 29.918886, -24.013197, 12.639232, 
                21.640959, 18.731186, 43.261206, 15.827659, -5.54708, 42.590275, 
                38.84683, 31.4659, 39.782334, -15.439505, -0.10599, -1.027727,  -15.6538,
                37.9062, 28.2336, -9.4295, 46.869107, 34.3015, -3.9962, 20.2559, 35.5296, 
                18.6657, 8.0817, 7.4951, 29.8739, 14.4974, -11.7922, 45.3435, -28.816623,
                30.217636, 34.8888, 1.2126, 32.2903, 27.8493, 29.1549, -4.0383),
  Latitude = c(-11.202692, 9.30769, 12.238333, -3.373056, 16.5388, 5.96607, 6.573778, 
               15.454166, -11.6455, -0.228021, 7.539988, 11.748718, 15.179384, -26.5225, 
               9.145, 13.443182, 13.443182, 7.257472, 11.8037, -1.2921, -29.609, 6.4281, 
               -18.8792, -13.2543, 17.5707, 20.3487, -18.6657, -22.9576, 17.6078, 9.0820, 
               -1.9403, 14.4974, 8.5636, 5.1521, -25.746111, 15.7887, -6.369028, 8.7808, 
               1.3733, -13.1339, -17.8252, -4.0383)
)

# Print the Coordinates data frame
print(Coordinates)
```

**Data Findings**

### Polity2 vs Population

```{r}
# Filter df2 for the year 2002
df2_2002 <- df2 %>% filter(year == 2002)

# Filter df2 for the year 2020
df2_2020 <- df2 %>% filter(year == 2020)

# Determine the y-axis limits based on both 2002 and 2020 data
y_axis_limits <- range(df2_2002$population / 1e6, df2_2020$population / 1e6)

# Create the scatter plot for year 2002 with labels for countries with polity2 values from 0 to -10
scatterplot_2002 <- ggplot(data = df2_2002, aes(x = polity2, y = population / 1e6, label = country)) +
  geom_point() +
  labs(x = "Polity2", y = "Population (in millions)") +
  ggtitle("Year 2002") +
  geom_text_repel(
    aes(x = polity2, y = population / 1e6),
    data = df2_2002 %>% filter(polity2 >= -10 & polity2 <= 0),
    size = 2,
    box.padding = 0.5
  ) +
  scale_y_continuous(labels = comma_format(), limits = y_axis_limits)  # Set y-axis limits

# Create the scatter plot for year 2020 with labels for countries with polity2 values from 0 to -10
scatterplot_2020 <- ggplot(data = df2_2020, aes(x = polity2, y = population / 1e6, label = country)) +
  geom_point(aes(color = ifelse(polity2 >= -10 & polity2 <= 0, "Highlighted", "Other")),
             size = 2) +
  labs(x = "Polity2", y = "Population (in millions)") +
  ggtitle("Year 2020") +
  geom_text_repel(
    aes(x = polity2, y = population / 1e6),
    data = df2_2020 %>% filter(polity2 >= -10 & polity2 <= 0),
    size = 2,
    box.padding = 0.5
  ) +
  scale_color_manual(values = c("Highlighted" = "red", "Other" = "black")) +
  theme(legend.position = "none") 

# Print the scatter plots separately for year 2002 and 2020
print(scatterplot_2002)
print(scatterplot_2020)

```
### Polity2 vs Total GDP

```{r}
# Create a scatter plot for polity2 vs. total_gdp in millions of USD
scatter_plotGDP <- ggplot(data = df2, aes(x = polity2, y = total_gdp / 1e6)) +  # Divide by 1e6 to convert to millions
  geom_point(aes(color = ifelse(polity2 >= -10 & polity2 <= 0, "Highlighted", "Other")), size = 2) +  # Highlight condition and reduce point size
  labs(x = "Polity2", y = "Total GDP (Millions USD)") +  
  ggtitle("") +
  scale_y_continuous(labels = scales::comma_format(scale = 1e-6)) +  # Format y-axis labels in millions
  scale_color_manual(values = c("Highlighted" = "red", "Other" = "black"))+
  theme(legend.position = "none") 

# Print the scatter plot
print(scatter_plotGDP)
```

### Military Expenditure by Country

```{r}
# Calculate the mean Military Expenditure by country and arrange in descending order
df2_mean <- df2 %>%
  group_by(country) %>%
  summarize(mean_afp = mean(`Military Expenditure`, na.rm = TRUE)) %>%
  arrange(desc(mean_afp))

# Filter out rows with NA in polity2_category
df2_filtered <- df2 %>%
  filter(!is.na(polity2_category))

# Create a box plot with fill based on polity2_category
box_plot <- ggplot(data = df2_filtered, aes(x = factor(country, levels = df2_mean$country), 
                                           y = `Military Expenditure` / 1e9,  # Convert to USD billion
                                           fill = polity2_category)) +
  geom_boxplot() +
  labs(x = "Country", y = "Military Expenditure (USD billion)") +  
  ggtitle("") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  
  labs(fill = "")

# Print the box plot
print(box_plot)
```
### Emergency Food Aid by Onset of War

```{r}
# Filter out NA values in the "onsetwar" variable
df2_filtered <- df2[!is.na(df2$onsetwar), ]

# Create a kernel density plot with a log-scale x-axis
kernel_density_plot <- ggplot(df2_filtered, aes(x = emergency_food_aid, fill = onsetwar)) +
  geom_density(alpha = 0.5) +  # Add a semi-transparent density plot
  labs(x = "Emergency Food Aid", y = "Density") +  # Set axis labels
  ggtitle("") +  # Set plot title
  scale_fill_manual(values = c("Yes" = "red", "No" = "blue")) +  # Define colors
  theme_minimal() + 
  scale_x_log10()  # Set x-axis to log scale

# Print the kernel density plot
print(kernel_density_plot)
```

### Emergency Food Aid by Overall Conflict

```{r}
# Filter out NA values in the "onsetwar" variable
df2_filtered <- df2[!is.na(df2$overall_conflict), ]

# Create a kernel density plot with a logarithmic x-axis scale
kernel_density_plot <- ggplot(df2_filtered, aes(x = emergency_food_aid, fill = overall_conflict)) +
  geom_density(alpha = 0.5) +  # Add a semi-transparent density plot
  labs(x = "Emergency Food Aid", y = "Density") +  # Set axis labels
  ggtitle("") +  # Set plot title
  scale_fill_manual(values = c("Yes" = "red", "No" = "blue")) +  # Define colors
  theme_minimal() + 
  scale_x_log10()  # Set x-axis to log scale

# Print the kernel density plot
print(kernel_density_plot)
```

### Battle Death by Emergency Food Aid

```{r}
# Filter out NA values in the "battle_deaths" and "emergency_food_aid" variables
df2_filtered <- df2 %>%
  filter(!is.na(battle_deaths) & !is.na(emergency_food_aid))

# Create a scatter plot with logarithmic x-axis scale and fill points based on "polity2_category"
correlation_plot <- ggplot(df2_filtered, aes(x = log(battle_deaths), y = emergency_food_aid, fill = polity2_category)) +
  geom_point(shape = 21, size = 3, data = . %>% filter(log(battle_deaths) != 0)) +  # Add scatter points with custom shape and size, excluding x=0 points
  
  labs(x = "Log(Battle Deaths)", y = "Emergency Food Aid") +  # Set axis labels
  ggtitle("") +  
  theme_minimal() +  
  scale_fill_manual(values = c("Highly Autocratic" = "red", "Moderately Autocratic" = "pink",
                               "Neutral/Transitional" = "grey", "Moderately Democratic" = "lightblue", 
                               "Highly Democratic" = "blue")) + 
  guides(fill = guide_legend(title = "Polity2 Category")) +  
  geom_rect(xmin = 3, xmax = 8, ymin = 0, ymax = 200,
            fill = "transparent", color = "blue", alpha = 0)  # Add transparent box

# Print the correlation plot
print(correlation_plot)
```
### Number of Battle Deaths by Country

```{r}
# Filter df2 for the year 2002
df2_2002 <- df2[df2$year == 2002, ]

# Create a basic map with a default view
map <- leaflet() %>%
  setView(lng = 12, lat = -8, zoom = 5) %>%
  addTiles()

# Define marker options for smaller markers
small_marker_options <- markerOptions(radius = 3, fillOpacity = 0.7)

# Iterate through the Coordinates dataset and add markers and labels for each country
for (i in 1:nrow(Coordinates)) {
  country_name <- Coordinates$Country[i]
  country_lng <- Coordinates$Longitude[i]
  country_lat <- Coordinates$Latitude[i]
  
  # Filter df2 for the specific country and year
  df2_country <- df2_2002 %>%
    filter(country == country_name)
  
  # Calculate the total battle deaths for the country
  total_battle_deaths <- sum(df2_country$battle_deaths, na.rm = TRUE)
  
  # Check if battle deaths should be hidden
  if (!is.na(total_battle_deaths) && total_battle_deaths > 1) {
    
    # Check if the country's polity2 value is within the range of 0 to -10
    polity2_value <- df2_country$polity2[1]  # Assuming it's the same for all rows of the same country in 2002
    if (!is.na(polity2_value) && polity2_value >= -10 && polity2_value <= 0) {
      # Add a marker with custom color for countries in the specified polity2 range
      map <- map %>%
        addCircleMarkers(
          lng = country_lng,
          lat = country_lat,
          radius = 10,  # Adjust the marker size
          color = "red",  # You can customize the marker color here
          fillOpacity = 0.7
        )
    } else {
      # Add a smaller marker for countries outside the specified polity2 range
      map <- map %>%
        addCircleMarkers(
          lng = country_lng,
          lat = country_lat,
          color = "blue",  # You can customize the marker color here
          options = small_marker_options  # Use the smaller marker options
        )
    }
    
    # Add a label for the country with total battle deaths information displayed permanently (rounded to whole numbers)
    label_text <- paste(country_name, ":", total_battle_deaths)
    
    map <- map %>%
      addLabelOnlyMarkers(
        lng = country_lng,
        lat = country_lat,
        label = label_text,
        labelOptions = labelOptions(noHide = TRUE, direction = "auto")
      )
    
  }
}

# Display the map
map
```

